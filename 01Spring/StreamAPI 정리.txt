Stream API

JDK8부터 지원되는 API 
데이터를 추상화하고, 처리하는데 자주 사용되는 함수들을 정의해둠.
추상화하였다는 것은 데이터의 종류에 상관없이 같은 방식으로 데이터를 처리할 수 있다는 것을 의미하며,
그에 따라 재사용성을 높일 수 있다.

Stream API의 특징
1. 원본의 데이터를 변경하지 않는다.
  -원본데이터를 읽어와 새로운 요소들로 Stream을 생성하기 때문에 데이터를 읽기만 할 뿐 변경하지 않고 정렬 필터링 등은 새로 생성한 Stream 객체에서 처리가 된다.
2. 일회용이다.
  -Stream API는 일회용이기 때문에 한번 사용하면 재사용이 불가능하다. 다시 사용하고 싶을경우 새로 생성해야한다.(닫힌 Stream을 사용한다면 IllegalStateException이 발생하게 된다.)
3. 내부 반복으로 작업을 처리한다.
  -Stream을 이용하면 코드가 간결해지는 이유 중 하나는 내부 반복 때문이다. 기존에는 반복문을 사용하기 위해 for 나 while 문을 사용해야 했지만, Stream에서는 그러한 반복 문법을 메소드 내부에 숨기고 있기 때문에, 보다 간결한 코드의 작성이 가능하다.

Stream API연산의 종류
1. 생성하기
  -Stream 객체를 생성하는 단계
  -Stream은 재사용이 불가능하므로, 닫히면 다시 생성해주어야한다.
   *)Stream연산을 하기 위해서는 먼저 객체를 생성해줘야한다.(배열, 컬렉션, 임의의 수, 파일 등 거의 모든 것을 가지고 생성 가능)
     주의할 점은 Stream이 닫히기 때문에, Stream이 닫혔을 경우 다시 Stream을 생성해야 한다.
2. 가공하기
  -원본의 데이터를 별도의 데이터로 가공하기 위한 중간 연산
  -연산 결과를 Stream으로 다시 반환하기 때문에 연속해서 중간연산을 이어갈 수 있다.
   *)가공하기 단계는 원본의 데이터를 별도의  데이터로 가공하기 위한 중간 연산의 단계이다. 
     어떤 객체의 Stream을 원하는 형태로 처리할 수 있으며, 중간 연상늬 반환값은 Stream이기 때문에 필요한 만큼 중간 연산을 연결하여 사용할 수 있다.
3. 결과만들기
  -가공된 데이터로부터 원하는 결과를 만들기 위한 최종 연산
  -Stream의 객체는 일회용으로 마지막에 이를 소모하며 연산이 수행되기 때문에 한 번만 처리가 가능하다.

--예제 코드
List<String> myList = Arrays.asList("a1", "a2", "b1", "c2", "c1");

myList
    .stream()				// 생성하기
    .filter(s -> s.startsWith("c"))			// 가공하기
    .map(String::toUpperCase)			// 가공하기
    .sorted()				// 가공하기
    .count();				// 결과만들기

위 코드에서는 먼저 stream()을 통해 Stream 객체를 생성하고, 중간에 데이터를 필터링하고, 변경하고, 정렬하는 중간연산을 진행하고있다.
이렇게 중간연산이 여러번 연결되는 것은 해당 중간연산이 Stream을 반환하기 때문이다(연산 파이프라인이라고 하기도 함)
최종 연산에서는 필요한 결과를 만들 수 있다.
위의 예제에서는 count()를 통해 남아있는 요소의 갯수를 최종적으로 반환하도록 되어 있다.


람다식
Stream 연산들은 매개변수로 함수형 인터페이스를 받도록 되어있다.
그리고 람다식은 반환값으로 함수형 인터페이스를 반환하고 있다.
그렇게 때문에 Stream API를 정확하게 이해하기 위해 람다식과 함수형 인터페이스에 대해 알고 있어야 한다.

기존 방식의 함수 
// 예시
public String hello() {
    return "Hello World!";
}

람다식으로는 위와 같은 메소드 명이 불필요하며, 다음과 같이 괄호()와 화살표 -> 를 이용해 함수를 선언하게 된다.
//예시 
() -> "Hello World"

람다식이 등장한 이유는 불필요한 코드를 줄이고, 가독성을 높이기 위함이다. 그렇기 때문에 
함수형 인터페이스의 인스턴스를 생성하여 함수를 변수처럼 선언하는 람다식에서는 
메소드의 이름이 불필요하다고 여겨져서 이를 사용하지 않는다.
대신 컴파일러가 문맥을 살펴 타입을 추론한다.
또한 람다식으로 선언된 함수는 1급 객체이기 때문에 Stream API의 매개변수로 전달이 가능해진다.

람다식의 특징
  -람다식 내에서 사용되는 지역변수는 final이 붙지 않아도 상수로 간주된다.
  -람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.

람다식의 장점
  -코드를 간결하게 만들 수 있다.
  -식에 개발자의 의도가 명확히 드러나 가독성이 높아진다.
  -함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.(익명함수)
  -병렬 프로그래밍이 용이하다.

람다식의 단점
  -람다를 사용하면서 만든 무명함수는 재사용이 불가능하다.
  -디버깅이 어렵다.
  -람다를 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있다.
  -재귀로 만들경우 부적합하다.

* 결국 무조건 람다가 좋다는 보장은 없다. 필요에 맞는 방법을 사용하는것이 중요하다.

함수형 인터페이스
Java는 기본적으로 객체지향 언어이기 때문에 순수 함수와 일반 함수를 다르게 취급하고 있으며,
이를 구분하기 위해 함수형 인터페이스가 등장하게 되었다.
함수형 인터페이스는 함수를 1급 객체처럼 다룰 수 있게 해주는 어노테이션으로,
인터페이스에 선언하여 단 하나의 추상메소드만을 갖도록 제한하는 역할을 한다.
함수형 인터페이스를 사용하는 이유는 Java의 람다식이 함수형 인터페이스를 반환하기 때문이다.

        // 기존의 익명함수
        System.out.println(new MyLambdaFunction() {
            public int max(int a, int b) {
                return a > b ? a : b;
            }
        }.max(3, 5));

두 값중 큰 값을 구하는 익명함수이다.
하지만 함수형 인터페이스의 등장으로 함수를 변수처럼 선언할 수 있게 되었고, 코드 역시 간결하게 작성할 수 있게 되었다.
함수형인터페이스를 구현하기 위해서는 인터페이스를 개발하여 그 내부에는 1개뿐인 abstract 함수를 선언하고,
위에는 @FunctionalInterface 어노테이션을 붙여주면 된다.


@FunctionalInterface
interface MyLambdaFunction {
    int max(int a, int b);
}

public class Lambda {

    public static void main(String[] args) {

        // 람다식을 이용한 익명함수
        MyLambdaFunction lambdaFunction = (int a, int b) -> a > b ? a : b;
        System.out.println(lambdaFunction.max(3, 5));
    }

}

람다식으로 생성된 순수 함수는 함수형 인터페이스로만 선언이 가능하다.
@FunctionalInterface 는 해당 인터페이스가 1개의 함수만을 갖도록 제한하기 때문에, 
여러 함수를 선언하면 컴파일 에러가 발생한다.

Java에서 제공하는 함수형 인터페이스
1. Supplier<T>
  -매개변수 없이 반환값 만을 갖는 함수형 인터페이스이다.
  -T get()을 추상메소드로 갖고 있다.

// 정의
@FunctionalInterface
public interface Supplier<T> {
    T get();
}

2. Consumer<T>
3. Function<T,R>
4. Predicate<T>
// 더 알아보기

// 사용 예시
Supplier<String> supplier = () -> "Hello World!";
System.out.println(supplier.get());

--출처 https://mangkyu.tistory.com/112
https://mangkyu.tistory.com/113 (이어서)